/*Generated by SharpKit 5 v5.01.1000*/
if (typeof ($CreateAnonymousDelegate) == 'undefined') {
    var $CreateAnonymousDelegate = function (target, func) {
        if (target == null || func == null)
            return func;
        var delegate = function () {
            return func.apply(target, arguments);
        };
        delegate.func = func;
        delegate.target = target;
        delegate.isDelegate = true;
        return delegate;
    }
}
if (typeof($CreateException)=='undefined') 
{
    var $CreateException = function(ex, error) 
    {
        if(error==null)
            error = new Error();
        if(ex==null)
            ex = new System.Exception.ctor();       
        error.message = ex.message;
        for (var p in ex)
           error[p] = ex[p];
        return error;
    }
}
if (typeof(JsTypes) == "undefined")
    var JsTypes = [];
var SharpAlg$Native$FactorialFunction =
{
    fullname: "SharpAlg.Native.FactorialFunction",
    baseTypeName: "SharpAlg.Native.SingleArgumentFunction",
    assemblyName: "SharpAlg.Implementation",
    interfaceNames: ["SharpAlg.Native.ISupportConvolution"],
    Kind: "Class",
    definition:
    {
        ctor: function ()
        {
            SharpAlg.Native.SingleArgumentFunction.ctor.call(this, "factorial");
        },
        Evaluate$$Number: function (arg)
        {
            var result = SharpAlg.Native.NumberFactory.One;
            for (var i = SharpAlg.Native.NumberFactory.Two; SharpAlg.Native.Number.op_LessThanOrEqual(i, arg); i = SharpAlg.Native.Number.op_Addition(i, SharpAlg.Native.NumberFactory.One))
            {
                result = SharpAlg.Native.Number.op_Multiply(result, i);
            }
            return result;
        },
        Convolute: function (context, args)
        {
            return SharpAlg.Native.MayBe.Return(SharpAlg.Native.MayBe.If(SharpAlg.Native.FunctionalExtensions.ConvertAs$1(SharpAlg.Native.ConstantExpr.ctor, System.Linq.Enumerable.First$1$$IEnumerable$1(SharpAlg.Native.Expr.ctor, args)), $CreateAnonymousDelegate(this, function (x)
            {
                return x.get_Value().get_IsInteger();
            })), $CreateAnonymousDelegate(this, function (x)
            {
                return SharpAlg.Native.Expr.Constant(this.Evaluate$$Number(x.get_Value()));
            }), $CreateAnonymousDelegate(this, function ()
            {
                return null;
            }));
        }
    }
};
JsTypes.push(SharpAlg$Native$FactorialFunction);
var SharpAlg$Native$ExpFunction =
{
    fullname: "SharpAlg.Native.ExpFunction",
    baseTypeName: "SharpAlg.Native.SingleArgumentDifferentiableFunction",
    staticDefinition:
    {
        MultiplyConvoultion: function (context, arg)
        {
            return SharpAlg.Native.MayBe.With(SharpAlg.Native.FunctionalExtensions.ConvertAs$1(SharpAlg.Native.MultiplyExpr.ctor, SharpAlg.Native.MayBe.With(arg, function (x)
            {
                return SharpAlg.Native.MultiplyExpressionExtractor.ExtractMultiply(x);
            })), function (x)
            {
                var lnExpr = System.Linq.Enumerable.FirstOrDefault$1$$IEnumerable$1$$Func$2(SharpAlg.Native.FunctionExpr.ctor, System.Linq.Enumerable.Cast$1(SharpAlg.Native.FunctionExpr.ctor, System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(SharpAlg.Native.Expr.ctor, x.get_Args(), function (y)
                {
                    return Is(y, SharpAlg.Native.FunctionExpr.ctor);
                })), function (y)
                {
                    return Is(context.GetFunction(y.get_FunctionName()), SharpAlg.Native.LnFunction.ctor);
                });
                if (lnExpr != null)
                {
                    return new SharpAlg.Native.Builder.ConvolutionExprBuilder(context).Power(System.Linq.Enumerable.First$1$$IEnumerable$1(SharpAlg.Native.Expr.ctor, lnExpr.get_Args()), SharpAlg.Native.Expr.Multiply$$IEnumerable$1$Expr(System.Linq.Enumerable.Where$1$$IEnumerable$1$$Func$2(SharpAlg.Native.Expr.ctor, x.get_Args(), function (y)
                    {
                        return y != lnExpr;
                    })));
                }
                return null;
            });
        },
        ConstantConvolution: function (arg)
        {
            return SharpAlg.Native.MayBe.Return(SharpAlg.Native.MayBe.If(arg, function (x)
            {
                return SharpAlg.Native.ImplementationExpressionExtensions.ExprEquals(x, SharpAlg.Native.Expr.Zero);
            }), function (x)
            {
                return SharpAlg.Native.Expr.One;
            }, function ()
            {
                return null;
            });
        }
    },
    assemblyName: "SharpAlg.Implementation",
    interfaceNames: ["SharpAlg.Native.ISupportConvolution"],
    Kind: "Class",
    definition:
    {
        ctor: function ()
        {
            SharpAlg.Native.SingleArgumentDifferentiableFunction.ctor.call(this, "exp");
        },
        Evaluate$$Number: function (arg)
        {
            return SharpAlg.Native.NumberFactory.Exp(arg);
        },
        DiffCore: function (builder, arg)
        {
            return SharpAlg.Native.FunctionFactory.Exp(arg);
        },
        Convolute: function (context, args)
        {
            var arg = System.Linq.Enumerable.Single$1$$IEnumerable$1(SharpAlg.Native.Expr.ctor, args);
            return (SharpAlg.Native.ExpFunction.ConstantConvolution(arg) != null ? SharpAlg.Native.ExpFunction.ConstantConvolution(arg) : SharpAlg.Native.ExpFunction.MultiplyConvoultion(context, arg));
        }
    }
};
JsTypes.push(SharpAlg$Native$ExpFunction);
var SharpAlg$Native$InvalidArgumentCountException =
{
    fullname: "SharpAlg.Native.InvalidArgumentCountException",
    baseTypeName: "System.Exception",
    assemblyName: "SharpAlg.Implementation",
    Kind: "Class",
    definition:
    {
        ctor: function ()
        {
            System.Exception.ctor.call(this);
        },
        ctor$$String: function (message)
        {
            System.Exception.ctor$$String.call(this, message);
        }
    }
};
JsTypes.push(SharpAlg$Native$InvalidArgumentCountException);
var SharpAlg$Native$LnFunction =
{
    fullname: "SharpAlg.Native.LnFunction",
    baseTypeName: "SharpAlg.Native.SingleArgumentDifferentiableFunction",
    staticDefinition:
    {
        PowerConvolution: function (context, arg)
        {
            return SharpAlg.Native.MayBe.Return(SharpAlg.Native.FunctionalExtensions.ConvertAs$1(SharpAlg.Native.PowerExpr.ctor, arg), function (x)
            {
                return SharpAlg.Native.Expr.Multiply$$Expr$$Expr(x.get_Right(), SharpAlg.Native.FunctionFactory.Ln(x.get_Left()));
            }, function ()
            {
                return null;
            });
        },
        InverseFunctionConvolution: function (context, arg)
        {
            return SharpAlg.Native.MayBe.Return(SharpAlg.Native.MayBe.If(SharpAlg.Native.FunctionalExtensions.ConvertAs$1(SharpAlg.Native.FunctionExpr.ctor, arg), function (x)
            {
                return Is(context.GetFunction(x.get_FunctionName()), SharpAlg.Native.ExpFunction.ctor);
            }), function (x)
            {
                return System.Linq.Enumerable.First$1$$IEnumerable$1(SharpAlg.Native.Expr.ctor, x.get_Args());
            }, function ()
            {
                return null;
            });
        },
        ConstantConvolution: function (arg)
        {
            return SharpAlg.Native.MayBe.Return(SharpAlg.Native.MayBe.If(arg, function (x)
            {
                return SharpAlg.Native.ImplementationExpressionExtensions.ExprEquals(x, SharpAlg.Native.Expr.One);
            }), function (x)
            {
                return SharpAlg.Native.Expr.Zero;
            }, function ()
            {
                return null;
            });
        }
    },
    assemblyName: "SharpAlg.Implementation",
    interfaceNames: ["SharpAlg.Native.ISupportConvolution"],
    Kind: "Class",
    definition:
    {
        ctor: function ()
        {
            SharpAlg.Native.SingleArgumentDifferentiableFunction.ctor.call(this, "ln");
        },
        Evaluate$$Number: function (arg)
        {
            return SharpAlg.Native.NumberFactory.Ln(arg);
        },
        DiffCore: function (builder, arg)
        {
            return builder.Inverse(arg);
        },
        Convolute: function (context, args)
        {
            var arg = System.Linq.Enumerable.Single$1$$IEnumerable$1(SharpAlg.Native.Expr.ctor, args);
            return (SharpAlg.Native.LnFunction.ConstantConvolution(arg) != null ? SharpAlg.Native.LnFunction.ConstantConvolution(arg) : (SharpAlg.Native.LnFunction.PowerConvolution(context, arg) != null ? SharpAlg.Native.LnFunction.PowerConvolution(context, arg) : SharpAlg.Native.LnFunction.InverseFunctionConvolution(context, arg)));
        }
    }
};
JsTypes.push(SharpAlg$Native$LnFunction);
var SharpAlg$Native$SingleArgumentDifferentiableFunction =
{
    fullname: "SharpAlg.Native.SingleArgumentDifferentiableFunction",
    baseTypeName: "SharpAlg.Native.SingleArgumentFunction",
    assemblyName: "SharpAlg.Implementation",
    interfaceNames: ["SharpAlg.Native.ISupportDiff"],
    Kind: "Class",
    definition:
    {
        ctor: function (name)
        {
            SharpAlg.Native.SingleArgumentFunction.ctor.call(this, name);
        },
        Diff: function (diffVisitor, args)
        {
            SharpAlg.Native.SingleArgumentFunction.CheckArgsCount$1(SharpAlg.Native.Expr.ctor, args);
            var arg = System.Linq.Enumerable.Single$1$$IEnumerable$1(SharpAlg.Native.Expr.ctor, args);
            return diffVisitor.get_Builder().Multiply(arg.Visit$1(SharpAlg.Native.Expr.ctor, diffVisitor), this.DiffCore(diffVisitor.get_Builder(), arg));
        }
    }
};
JsTypes.push(SharpAlg$Native$SingleArgumentDifferentiableFunction);
var SharpAlg$Native$SingleArgumentFunction =
{
    fullname: "SharpAlg.Native.SingleArgumentFunction",
    baseTypeName: "SharpAlg.Native.Function",
    staticDefinition:
    {
        IsValidArgsCount$1: function (T, args)
        {
            return System.Linq.Enumerable.Count$1$$IEnumerable$1(T, args) == 1;
        },
        CheckArgsCount$1: function (T, args)
        {
            if (!SharpAlg.Native.SingleArgumentFunction.IsValidArgsCount$1(T, args))
                throw $CreateException(new SharpAlg.Native.InvalidArgumentCountException.ctor(), new Error());
        }
    },
    assemblyName: "SharpAlg.Implementation",
    interfaceNames: ["SharpAlg.Native.ISupportCheckArgs"],
    Kind: "Class",
    definition:
    {
        ctor: function (name)
        {
            SharpAlg.Native.Function.ctor.call(this, name);
        },
        Evaluate: function (evaluator, args)
        {
            return this.EvaluateCore(System.Linq.Enumerable.Select$2$$IEnumerable$1$$Func$2(SharpAlg.Native.Expr.ctor, SharpAlg.Native.Number.ctor, args, $CreateAnonymousDelegate(this, function (x)
            {
                return x.Visit$1(SharpAlg.Native.Number.ctor, evaluator);
            })));
        },
        EvaluateCore: function (args)
        {
            SharpAlg.Native.SingleArgumentFunction.CheckArgsCount$1(SharpAlg.Native.Number.ctor, args);
            return this.Evaluate$$Number(System.Linq.Enumerable.Single$1$$IEnumerable$1(SharpAlg.Native.Number.ctor, args));
        },
        Check: function (args)
        {
            return SharpAlg.Native.SingleArgumentFunction.IsValidArgsCount$1(SharpAlg.Native.Expr.ctor, args) ? System.String.Empty : System.String.Format$$String$$Object$$Object("Error, (in {0}) expecting 1 argument, got {1}", this.get_Name(), System.Linq.Enumerable.Count$1$$IEnumerable$1(SharpAlg.Native.Expr.ctor, args));
        }
    }
};
JsTypes.push(SharpAlg$Native$SingleArgumentFunction);
